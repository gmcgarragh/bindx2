/*******************************************************************************
**
**    Copyright (C) 2011-2018 Greg McGarragh <gregm@atmos.colostate.edu>
**
**    This source code is licensed under the GNU General Public License (GPL),
**    Version 3.  See the file COPYING for more details.
**
*******************************************************************************/

#include <gutil.h>

#include "bindx_c.h"
#include "bindx_f77.h"
#include "bindx_parse.h"
#include "bindx_parse_int.h"


static int write_header(FILE *fp)
{
     fprintf(fp, "c***********************************************************************\n");
     fprintf(fp, "c\n");
     fprintf(fp, "c***********************************************************************\n");

     return 0;
}



static int write_header_top(FILE *fp)
{
     fprintf(fp, "c***********************************************************************\n");
     fprintf(fp, "c This file was generated by bindx version %s.  Edit at your own risk.\n",
             bindx_version());
     fprintf(fp, "c***********************************************************************\n");

     return 0;
}



static int bindx_write_c_util_header(FILE *fp, const bindx_data *d)
{
     fprintf(fp, "#include <gutil.h>\n");
     fprintf(fp, "\n");
     fprintf(fp, "#include <%s_interface.h>\n", d->prefix);
     fprintf(fp, "\n");
     fprintf(fp, "#ifdef __cplusplus\n");
     fprintf(fp, "extern \"C\" {\n");
     fprintf(fp, "#endif\n");
     fprintf(fp, "\n");
     fprintf(fp, "\n");

     return 0;
}



static int bindx_write_c_util_trailer(FILE *fp, const bindx_data *d)
{
     fprintf(fp, "#ifdef __cplusplus\n");
     fprintf(fp, "}\n");
     fprintf(fp, "#endif\n");

     return 0;
}



static int bindx_write_c_util_functions(FILE *fp, const bindx_data *d,
                                        const subprogram_data *subs)
{
     int i;

     char *name;

     char *indent = "     ";

     argument_data *argument;
     subprogram_data *subprogram;

     list_for_each(subs, subprogram) {
          bindx_write_c_type(fp, d, &subprogram->type, NULL);
          name = strdup(subprogram->name);
          for (i = 0; name[i] != '\0'; ++i)
               name[i] = tolower(name[i]);

          fprintf(fp, " %s_%s_bindx_f77_(%s_data *d", d->prefix, name, d->prefix);

          free(name);

          list_for_each(subprogram->args, argument) {
               fprintf(fp, ", ");
               if (argument->options & SUBPROGRAM_ARGUMENT_OPTION_MASK_ENUM_EXTERNAL)
                    bindx_write_c_type(fp, d, &argument->type, argument->enum_external_type);
               else
                    bindx_write_c_type(fp, d, &argument->type, NULL);
               fprintf(fp, " ");
               fprintf(fp, "*");
               fprintf(fp, "%s", argument->name);
               if (argument->usage == LEX_SUBPROGRAM_ARGUMENT_USAGE_IN &&
                   argument->type.rank == 0)
                    fprintf(fp, "_");
          }

          fprintf(fp, ")\n");
          fprintf(fp, "{\n");

          list_for_each(subprogram->args, argument) {
               if ((argument->usage == LEX_SUBPROGRAM_ARGUMENT_USAGE_IN &&
                    argument->type.rank == 0) || argument->type.rank  > 1) {
                    fprintf(fp, "%s", indent);
                    if (argument->options & SUBPROGRAM_ARGUMENT_OPTION_MASK_ENUM_EXTERNAL)
                         bindx_write_c_type(fp, d, &argument->type,
                                            argument->enum_external_type);
                    else
                         bindx_write_c_type(fp, d, &argument->type, NULL);
                    fprintf(fp, " ");
                    for (i = 0; i < argument->type.rank; ++i)
                         fprintf(fp, "*");
                    fprintf(fp, "%s", argument->name);
                    if (argument->type.rank > 1)
                         fprintf(fp, "2");
                    fprintf(fp, ";\n");
               }
          }

          list_for_each(subprogram->args, argument) {
               if (argument->usage == LEX_SUBPROGRAM_ARGUMENT_USAGE_IN &&
                   argument->type.rank == 0) {
                    fprintf(fp, "%s", indent);
                    fprintf(fp, "%s = *%s_", argument->name, argument->name);
                    fprintf(fp, ";\n");
               }
          }

          list_for_each(subprogram->args, argument) {
               if (argument->type.rank > 1) {
                    fprintf(fp, "%s%s2 = array_from_mem%d_d(%s, ", indent,
                            argument->name, argument->type.rank, argument->name);

                    for (i = 0; i < argument->type.rank; ++i) {
                         fprintf(fp, "%s", argument->type.dimens[i]);
                         if (i + 1 < argument->type.rank)
                              fprintf(fp, ", ");
                    }

                    fprintf(fp, ");\n");
               }
          }

          fprintf(fp, "%sif (%s_%s(d", indent, d->prefix, subprogram->name);

          list_for_each(subprogram->args, argument) {
               fprintf(fp, ", ");
               if (argument->type.type == LEX_BINDX_TYPE_ENUM) {
                    if (argument->options & SUBPROGRAM_ARGUMENT_OPTION_MASK_ENUM_EXTERNAL)
                         fprintf(fp, "(enum %s_%s", argument->enum_external_type,
                                 argument->type.name);
                    else
                         fprintf(fp, "(enum %s_%s", d->prefix, argument->type.name);
                    for (i = 0; i < argument->type.rank; ++i)
                          fprintf(fp, "*");
                    fprintf(fp, ") ");
               }
               fprintf(fp, "%s", argument->name);
               if (argument->type.rank > 1)
                    fprintf(fp, "2");
          }

          fprintf(fp, ")) {\n");

          fprintf(fp, "%s%seprintf(\"ERROR: %s_%s()\\n\");\n", indent, indent,
                  d->prefix, subprogram->name);
          fprintf(fp, "%s%sreturn -1;\n", indent, indent);

          fprintf(fp, "%s}\n", indent);

          list_for_each(subprogram->args, argument) {
               if (argument->type.rank > 1)
                    fprintf(fp, "%sfree_array%d_d(%s2);\n", indent,
                            argument->type.rank, argument->name);
          }

          fprintf(fp, "%sreturn 0;\n", indent);

          fprintf(fp, "}\n");
          fprintf(fp, "\n");
          fprintf(fp, "\n");
     }

     return 0;
}



static void fprintf_f77(FILE *fp, const char *fmt, ...)
{
     va_list ap;

     va_start(ap, fmt);

     bindx_fprintf_wrap(fp, 72, "     &", fmt, ap);

     va_end(ap);
}



static int write_type(FILE *fp, const type_data *d)
{
     switch(d->type) {
          case LEX_BINDX_TYPE_ENUM:
               fprintf_f77(fp, "integer");
               break;
          case LEX_BINDX_TYPE_CHAR:
               fprintf_f77(fp, "character");
               break;
          case LEX_BINDX_TYPE_INT:
               fprintf_f77(fp, "integer");
               break;
          case LEX_BINDX_TYPE_DOUBLE:
               fprintf_f77(fp, "real*8");
               break;
          case LEX_BINDX_TYPE_STRUCTURE:
               fprintf_f77(fp, "byte");
               break;
          default:
               INTERNAL_ERROR("Invalid lex_bindx_type value: %d", d->type);
               break;
     }

     return 0;
}



static int write_dimens(FILE *fp, const type_data *d)
{
     if (d->rank > 0 || d->type == LEX_BINDX_TYPE_STRUCTURE) {
          fprintf_f77(fp,"(");

          fprintf_f77(fp,"*");

          fprintf_f77(fp,")");
     }

     return 0;
}



static int write_enumerations(FILE *fp, const bindx_data *d,
                              const enumeration_data *enums)
{
     enum_member_data *enum_member;
     enumeration_data *enumeration;

     list_for_each(enums, enumeration) {
          list_for_each(enumeration->members, enum_member) {
               fprintf_f77(fp, "      integer %s_%s\n", d->PREFIX,
                           enum_member->name);
               fprintf_f77(fp, "      parameter (%s_%s = %d_8)\n", d->PREFIX,
                           enum_member->name, enum_member->value);
          }

          fprintf_f77(fp, "\n");
     }

     return 0;
}



static int write_structures(FILE *fp, const bindx_data *d,
                            const structure_data *structs)
{
     int i;

     char *name;

     structure_data *structure;

     list_for_each(structs, structure) {
          name = strdup(structure->name);
          for (i = 0; name[i] != '\0'; ++i)
               name[i] = toupper(name[i]);

          fprintf_f77(fp, "      integer N_BYTES_%s\n", name);
          fprintf_f77(fp, "      parameter (N_BYTES_%s = %lu)\n", name,
                      structure->size);

          free(name);
     }

     return 0;
}



static int write_subprograms(FILE *fp, const bindx_data *d,
                             const subprogram_data *subs)
{
     char *indent = "      ";

     argument_data *argument;
     subprogram_data *subprogram;

     list_for_each(subs, subprogram) {
          fprintf_f77(fp, "%s", indent);

          if (subprogram->has_return_value ||
              subprogram_n_scaler_out_args(subprogram) == 1) {
               write_type(fp, &subprogram->type);
               fprintf_f77(fp, " function %s_%s_f77(d", d->prefix, subprogram->name);
          }
          else
               fprintf_f77(fp, "subroutine %s_%s_f77(d", d->prefix, subprogram->name);

          list_for_each(subprogram->args, argument)
               fprintf_f77(fp, ", %s", argument->name);

          if (! subprogram->has_return_value &&
              subprogram_n_scaler_out_args(subprogram) != 1)
               fprintf_f77(fp, ", error");

          fprintf_f77(fp, ")\n");

          fprintf_f77(fp, "%simplicit none\n", indent);

          fprintf_f77(fp, "%sbyte d(*)\n", indent);

          list_for_each(subprogram->args, argument) {
               fprintf_f77(fp, "%s", indent);
               write_type(fp, &argument->type);
               fprintf_f77(fp, " ");
               fprintf_f77(fp, "%s", argument->name);
               write_dimens(fp, &argument->type);
               fprintf_f77(fp, "\n");
          }

          if (! subprogram->has_return_value &&
              subprogram_n_scaler_out_args(subprogram) != 1)
               fprintf_f77(fp, "%sinteger error\n", indent);

          fprintf_f77(fp, "%sinteger %s_%s_bindx_f77\n", indent, d->prefix,
                      subprogram->name);

          if (subprogram->has_return_value ||
              subprogram_n_scaler_out_args(subprogram) == 1)
               fprintf_f77(fp, "%s%s_%s_f77 = ", indent, d->prefix, subprogram->name);
          else
               fprintf_f77(fp, "%serror = ", indent);

          fprintf_f77(fp, "%s_%s", d->prefix, subprogram->name);
          fprintf_f77(fp, "_bindx_f77");
          fprintf_f77(fp, "(d");

          list_for_each(subprogram->args, argument)
               fprintf_f77(fp, ", %s", argument->name);

          fprintf_f77(fp, ")\n");

          fprintf_f77(fp, "%s", indent);
          if (subprogram->has_return_value ||
              subprogram_n_scaler_out_args(subprogram) == 1)
               fprintf_f77(fp, "end function %s_%s_f77\n", d->prefix, subprogram->name);
          else
               fprintf_f77(fp, "end subroutine %s_%s_f77\n", d->prefix, subprogram->name);
          fprintf_f77(fp, "\n");
          fprintf_f77(fp, "\n");
     }

     return 0;
}



int bindx_write_f77(FILE **fp, const bindx_data *d, const char *name)
{
     bindx_write_c_header_top(fp[0]);
     fprintf(fp[0], "\n");

     bindx_write_c_util_header(fp[0], d);
     bindx_write_c_util_functions(fp[0], d, &d->subs_all);
     bindx_write_c_util_trailer(fp[0], d);

     write_header_top(fp[1]);
     fprintf_f77(fp[1], "\n");
     fprintf_f77(fp[1], "\n");

     write_header(fp[1]);
     write_enumerations(fp[1], d, &d->enums);
     fprintf_f77(fp[1], "\n");
     fprintf_f77(fp[1], "\n");

     write_header(fp[1]);
     write_structures(fp[1], d, &d->structs);
     fprintf_f77(fp[1], "\n");
     fprintf_f77(fp[1], "\n");
     fprintf_f77(fp[1], "\n");

     write_header_top(fp[2]);
     fprintf_f77(fp[2], "\n");
     fprintf_f77(fp[2], "\n");
     write_subprograms(fp[2], d, &d->subs_all);

     return 0;
}
