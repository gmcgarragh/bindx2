/******************************************************************************%
**
**    Copyright (C) 2011-2017 Greg McGarragh <gregm@atmos.colostate.edu>
**
**    This source code is licensed under the GNU General Public License (GPL),
**    Version 3.  See the file COPYING for more details.
**
*******************************************************************************/

#include <gutil.h>

#include "bindx_c.h"
#include "bindx_parse.h"
#include "bindx_parse_int.h"


size_t bindx_c_type_size(const type_data *type)
{
     switch(type->type) {
          case LEX_BINDX_TYPE_CHAR:
               return sizeof(char);
               break;
          case LEX_BINDX_TYPE_INT:
               return sizeof(int);
               break;
          case LEX_BINDX_TYPE_DOUBLE:
               return sizeof(double);
               break;
          default:
               INTERNAL_ERROR("Invalid lex_bindx_type value: %d", type->type);
               break;
     }

     return 0;
}


int bindx_write_c_header(FILE *fp)
{
     fprintf(fp, "/*******************************************************************************\n");
     fprintf(fp, " *\n");
     fprintf(fp, " ******************************************************************************/\n");

     return 0;
}



int bindx_write_c_header_top(FILE *fp)
{
     fprintf(fp, "/*******************************************************************************\n");
     fprintf(fp, " * This file was generated by bindx version %s.  Edit at your own risk.\n",
             bindx_version());
     fprintf(fp, " ******************************************************************************/\n");

     return 0;
}



int bindx_write_c_type(FILE *fp, const bindx_data *d, const type_data *type,
                       const char *prefix)
{
     switch(type->type) {
          case LEX_BINDX_TYPE_ENUM:
               if (prefix)
                    fprintf(fp, "enum %s_%s", prefix, type->name);
               else
                    fprintf(fp, "enum %s_%s", d->prefix, type->name);
               break;
          case LEX_BINDX_TYPE_CHAR:
               fprintf(fp, "char");
               break;
          case LEX_BINDX_TYPE_INT:
               fprintf(fp, "int");
               break;
          case LEX_BINDX_TYPE_DOUBLE:
               fprintf(fp, "double");
               break;
          case LEX_BINDX_TYPE_STRUCTURE:
               fprintf(fp, "%s", type->name);
               break;
          default:
               INTERNAL_ERROR("Invalid lex_bindx_type value: %d", type->type);
               break;
     }

     return 0;
}



int bindx_write_c_dimens(FILE *fp, const bindx_data *d, const type_data *type)
{
     int i;

     for (i = 0; i < type->rank; ++i)
          fprintf(fp, "*");

     return 0;
}



int bindx_write_c_dimens_args(FILE *fp, const bindx_data *d, const type_data *type,
                              enum lex_subprogram_argument_usage usage)
{
     if (type->type == LEX_BINDX_TYPE_STRUCTURE)
          fprintf(fp, "*");
     else
     if (type->rank == 0 && usage == LEX_SUBPROGRAM_ARGUMENT_USAGE_OUT)
          fprintf(fp, "*");
     else
          return bindx_write_c_dimens(fp, d, type);

     return 0;
}



int bindx_write_c_dimens_return(FILE *fp, const bindx_data *d, const type_data *type)
{
     return bindx_write_c_dimens(fp, d, type);
}



int bindx_write_c_declaration(FILE *fp, const bindx_data *d, const type_data *type,
                              const char *prefix)
{
     bindx_write_c_type(fp, d, type, prefix);
     fprintf(fp, " ");
     bindx_write_c_dimens(fp, d, type);

     return 0;
}



int bindx_write_c_enum_mask_init(FILE *fp, struct list_data *list, const char *name,
                                 const char *prefix, int indent)
{
     char temp[NM];

     struct list_data *item;

     fprintf(fp, "%s%s = 0;\n", bxis(indent), name);

     list_for_each(list, item) {
          if (strcmp(item->name, "null") == 0)
               break;
          strtoupper(item->name, temp);
          fprintf(fp, "%s%s |= %s%s;\n", bxis(indent), name, prefix, temp);
     }

     return 0;
}



int bindx_write_c_enum_array_init(FILE *fp, struct list_data *list, const char *name,
                                  const char *prefix, int indent)
{
     char temp[NM];

     struct list_data *item;

     fprintf(fp, "%si = 0;\n", bxis(indent));

     list_for_each(list, item) {
          if (strcmp(item->name, "null") == 0)
               break;
          strtoupper(item->name, temp);
          fprintf(fp, "%s%s[i++] = %s%s;\n", bxis(indent), name, prefix, temp);
     }

     return 0;
}
