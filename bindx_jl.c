/*******************************************************************************
**
**    Copyright (C) 2011-2018 Greg McGarragh <greg.mcgarragh@colostate.edu>
**
**    This source code is licensed under the GNU General Public License (GPL),
**    Version 3.  See the file COPYING for more details.
**
*******************************************************************************/

#include <gutil.h>

#include "bindx_c.h"
#include "bindx_jl.h"
#include "bindx_parse.h"
#include "bindx_parse_int.h"
#include "bindx_util.h"


static const char *type_to_julia_type(const type_data *d)
{
     switch(d->type) {
          case LEX_BINDX_TYPE_INT:
               return "Int32";
               break;
          case LEX_BINDX_TYPE_DOUBLE:
               return "Float64";
               break;
          default:
               INTERNAL_ERROR("Invalid lex_bindx_type value: %d", d->type);
               break;
     }

     return NULL;
}



static const char *type_to_julia_c_alias(const type_data *d, int flag, int flag2)
{
     switch(d->type) {
          case LEX_BINDX_TYPE_VOID:
               return "Cvoid";
               break;
          case LEX_BINDX_TYPE_ENUM:
               return "Cint";
               break;
          case LEX_BINDX_TYPE_INT:
               return "Cint";
               break;
          case LEX_BINDX_TYPE_DOUBLE:
               return "Cdouble";
               break;
          default:
               INTERNAL_ERROR("Invalid lex_bindx_type value: %d", d->type);
               break;
     }

     return NULL;
}



static const char *type_to_julia_c_type(const type_data *d, int flag, int flag2)
{
     switch(d->type) {
          case LEX_BINDX_TYPE_VOID:
               if (d->rank == 0 && ! flag)
                    return "Cvoid";
               else {
                    if (! flag2)
                         return "Ptr{Cvoid}";
                    else
                         return "Ref{Cvoid}";
               }
               break;
          case LEX_BINDX_TYPE_ENUM:
               if (d->rank == 0 && ! flag)
                    return "Cint";
               else {
                    if (! flag2)
                         return "Ptr{Cint}";
                    else
                         return "Ref{Cint}";
               }
               break;
          case LEX_BINDX_TYPE_INT:
               if (d->rank == 0 && ! flag)
                    return "Cint";
               else {
                    if (! flag2)
                         return "Ptr{Cint}";
                    else
                         return "Ref{Cint}";
               }
               break;
          case LEX_BINDX_TYPE_DOUBLE:
               if (d->rank == 0 && ! flag)
                    return "Cdouble";
               else {
                    if (! flag2)
                         return "Ptr{Cdouble}";
                    else
                         return "Ref{Cdouble}";
               }
               break;
          default:
               INTERNAL_ERROR("Invalid lex_bindx_type value: %d", d->type);
               break;
     }

     return NULL;
}



static int write_header(FILE *fp)
{
     fprintf(fp, "#***********************************************************************\n");
     fprintf(fp, "#\n");
     fprintf(fp, "#***********************************************************************\n");

     return 0;
}



static int write_header_top(FILE *fp)
{
     fprintf(fp, "#***********************************************************************\n");
     fprintf(fp, "# This file was generated by bindx version %s.  Edit at your own risk.\n",
             bindx_version());
     fprintf(fp, "#***********************************************************************\n");

     return 0;
}



static int bindx_write_c_util_functions(FILE *fp, const bindx_data *d,
                                        const subprogram_data *subs)
{
     int i;

     int indent = 0;

     argument_data *argument;
     argument_data *argument2;
     subprogram_data *subprogram;

     list_for_each(subs, subprogram) {
          list_for_each(subprogram->args, argument) {
               if (argument->options.flags & SUBPROGRAM_ARGUMENT_OPTION_MASK_ENUM_MASK ||
                   argument->options.flags & SUBPROGRAM_ARGUMENT_OPTION_MASK_ENUM_ARRAY)
                   continue;
               else
               if (argument->type.rank > 0) {
                    fprintf(fp, "int %s_%s_dims(%s_data *d, ",
                            subprogram->name, argument->name, d->prefix);

                    list_for_each(subprogram->args, argument2) {
                         if (argument2->usage != LEX_SUBPROGRAM_ARGUMENT_USAGE_OUT) {
                              bindx_write_c_type(fp, d, &argument2->type, NULL);
                              fprintf(fp, " ");
                              bindx_write_c_dimens_args(fp, d, &argument2->type,
                                                                argument2->usage);
                              fprintf(fp, "%s, ", argument2->name);
                         }
                    }
                    fprintf(fp, "size_t *dims)\n");

                    fprintf(fp, "{\n");
                    indent++;

                    for (i = 0; i < argument->type.rank; ++i)
                         fprintf(fp, "%sdims[%d] = %s;\n",
                                 bxis4(indent), i, argument->type.dimens[i]);

                    fprintf(fp, "%sreturn 0;\n", bxis4(indent));
                    indent--;
                    fprintf(fp, "}\n");

                    fprintf(fp, "\n");
                    fprintf(fp, "\n");
               }
          }
     }

     return 0;
}



static int write_global_consts(FILE *fp, const bindx_data *d,
                               const global_const_data *consts)
{
     global_const_data *global_const;

     list_for_each(consts, global_const) {
          fprintf(fp, "%s = ", global_const->name);
          switch(global_const->type.type) {
          case LEX_BINDX_TYPE_INT:
               fprintf(fp, "%ld", global_const->lex_type.l);
               break;
          case LEX_BINDX_TYPE_DOUBLE:
               fprintf(fp, "%f", global_const->lex_type.d);
               break;
          default:
               INTERNAL_ERROR("Invalid lex_bindx_type value: %d", global_const->type.type);
               break;
          }
          fprintf(fp, "\n");
     }

     return 0;
}



static int write_utilities(FILE *fp, const bindx_data *d)
{
     fprintf(fp, "function list_to_mask(list, name_to_mask)\n");
     fprintf(fp, "    mask = 0\n");
     fprintf(fp, "    n = length(list)\n");
     fprintf(fp, "    for i = 1:n\n");
     fprintf(fp, "        r = @eval ccall(($name_to_mask, library_path), Cint, (Cstring, ), $(string(list[i])))\n");
     fprintf(fp, "        if r == -1\n");
     fprintf(fp, "            error(\"list_to_mask()\")\n");
     fprintf(fp, "        end\n");
     fprintf(fp, "        mask |= r\n");
     fprintf(fp, "    end\n");
     fprintf(fp, "    mask\n");
     fprintf(fp, "end\n");
     fprintf(fp, "\n");
     fprintf(fp, "\n");
/*
     fprintf(fp, "function mask_to_list(mask, n, index_to_mask, index_to_name)\n");
     fprintf(fp, "    list = Vector{String}(undef, 0)\n");
     fprintf(fp, "    for i = 1:n\n");
     fprintf(fp, "        mask2 = @eval ccall(($index_to_mask, library_path), Cint, (Cint, ), $(i - 1))\n");
     fprintf(fp, "        if mask & mask2 != 0\n");
     fprintf(fp, "            name = @eval ccall(($index_to_name, library_path), Cstring, (Cint, ), $(i - 1))\n");
     fprintf(fp, "            push!(list, unsafe_string(name))\n");
     fprintf(fp, "        end\n");
     fprintf(fp, "    end\n");
     fprintf(fp, "    list\n");
     fprintf(fp, "end\n");
     fprintf(fp, "\n");
     fprintf(fp, "\n");
*/
     fprintf(fp, "function mask_to_list(mask, index_to_mask, index_to_name)\n");
     fprintf(fp, "    list = Vector{String}(undef, 0)\n");
     fprintf(fp, "    global i = 1\n");
     fprintf(fp, "    while true\n");
     fprintf(fp, "        mask2 = @eval ccall(($index_to_mask, library_path), Cint, (Cint, ), $(i - 1))\n");
     fprintf(fp, "        if mask2 == -1\n");
     fprintf(fp, "            break\n");
     fprintf(fp, "        end\n");
     fprintf(fp, "        if mask & mask2 != 0\n");
     fprintf(fp, "            name = @eval ccall(($index_to_name, library_path), Cstring, (Cint, ), $(i - 1))\n");
     fprintf(fp, "            push!(list, unsafe_string(name))\n");
     fprintf(fp, "        end\n");
     fprintf(fp, "        global i += 1\n");
     fprintf(fp, "    end\n");
     fprintf(fp, "    list\n");
     fprintf(fp, "end\n");
     fprintf(fp, "\n");
     fprintf(fp, "\n");

     fprintf(fp, "function list_to_array(list, name_to_value)\n");
     fprintf(fp, "    n = length(list)\n");
     fprintf(fp, "    array = Array{Int32,1}(undef, n)\n");
     fprintf(fp, "    for i = 1:n\n");
     fprintf(fp, "        r = @eval ccall(($name_to_value, library_path), Cint, (Cstring, ), $(string(list[i])))\n");
     fprintf(fp, "        if r == -1 0\n");
     fprintf(fp, "            error(\"list_to_mask()\")\n");
     fprintf(fp, "        end\n");
     fprintf(fp, "        array[i] = r\n");
     fprintf(fp, "    end\n");
     fprintf(fp, "    n, array\n");
     fprintf(fp, "end\n");
     fprintf(fp, "\n");
     fprintf(fp, "\n");

     return 0;
}



static int write_subprograms(FILE *fp, const bindx_data *d,
                             enum subprogram_type sub_type,
                             const subprogram_data *subs)
{
     int i;
     int ii;

     int flag;

     int indent = 0;

     char *crap = "";

     char *postfix = "";

     argument_data *argument;
     argument_data *argument2;
     subprogram_data *subprogram;

     list_for_each(subs, subprogram) {
          /**** Start function declaration ****/

          fprintf(fp, "function %s(", subprogram->name);
          if (sub_type != SUBPROGRAM_TYPE_INIT) {
               fprintf(fp, "d");
               if (subprogram_n_in_args(subprogram) > 0)
                    fprintf(fp, ", ");
          }

          list_for_each(subprogram->args, argument) {
               if (argument->usage != LEX_SUBPROGRAM_ARGUMENT_USAGE_IN)
                    continue;

               if (argument->type.rank == 0 && argument->type.type == LEX_BINDX_TYPE_ENUM)
                    fprintf(fp, "%s_string::String", argument->name);
               else
               if (argument->options.flags & SUBPROGRAM_ARGUMENT_OPTION_MASK_ENUM_MASK ||
                   argument->options.flags & SUBPROGRAM_ARGUMENT_OPTION_MASK_ENUM_ARRAY)
                    fprintf(fp, "%s_list::Vector{String}", argument->name);
               else
               if (argument->options.flags & SUBPROGRAM_ARGUMENT_OPTION_MASK_LIST_SIZE)
                    continue;
               else
               if (argument->type.rank > 0)
                    fprintf(fp, "%s::Array{%s, %d}", argument->name,
                            type_to_julia_type(&argument->type), argument->type.rank);
               else
                    fprintf(fp, "%s", argument->name);

               if (! list_is_last_elem(subprogram->args, argument) &&
                   ((argument_data *) list_next_elem(argument))->usage == LEX_SUBPROGRAM_ARGUMENT_USAGE_IN)
                    fprintf(fp, ", ");
          }

          fprintf(fp, ")\n");


          indent++;


          /**** Convert lists to masks or arrays ****/

          list_for_each(subprogram->args, argument) {
               if (argument->type.rank == 0 && argument->type.type == LEX_BINDX_TYPE_ENUM) {
                    fprintf(fp, "%s%s = ccall((:%s, library_path), Cint, (Cstring, ), %s_string)\n",
                            bxis4(indent), argument->name, argument->options.enum_name_to_value, argument->name);
                    fprintf(fp, "%sif %s == -1\n", bxis4(indent), argument->name);
                    indent++;
                    fprintf(fp, "%serror(\"%s()\")\n", bxis4(indent), argument->options.enum_name_to_value);
                    indent--;
                    fprintf(fp, "%send\n", bxis4(indent));
               }
               else
               if (argument->options.flags & SUBPROGRAM_ARGUMENT_OPTION_MASK_ENUM_MASK)
                    fprintf(fp, "%s%s = list_to_mask(%s_list, \"%s\")\n",
                            bxis4(indent), argument->name, argument->name,
                            argument->options.enum_name_to_value);
               else
               if (argument->options.flags & SUBPROGRAM_ARGUMENT_OPTION_MASK_ENUM_ARRAY)
                    fprintf(fp, "%sn_%s, %s = list_to_array(%s_list, \"%s\")\n",
                            bxis4(indent), argument->name, argument->name, argument->name,
                            argument->options.enum_name_to_value);
          }


          /**** Get dimensions****/

          if (sub_type == SUBPROGRAM_TYPE_GENERAL) {
              list_for_each(subprogram->args, argument) {
                   if (argument->type.rank > 0) {
                        fprintf(fp, "%sdims_%s = Array{UInt64, 1}(undef, (%d))\n",
                                bxis4(indent), argument->name, argument->type.rank);

                        fprintf(fp, "%sr = ccall((:%s_%s_dims, library_path), Cint, (Ptr{Cvoid}, ",
                                bxis4(indent), subprogram->name, argument->name);

                        list_for_each(subprogram->args, argument2) {
                             if (argument2->usage == LEX_SUBPROGRAM_ARGUMENT_USAGE_IN) {
                                  fprintf(fp, "%s, ", type_to_julia_c_type(&argument2->type,
                                          argument2->type.rank == 0 &&
                                          argument2->usage == LEX_SUBPROGRAM_ARGUMENT_USAGE_OUT,
                                          argument2->usage == LEX_SUBPROGRAM_ARGUMENT_USAGE_OUT));
                             }
                        }
                        fprintf(fp, "Ref{Csize_t}), ");

                        fprintf(fp, "d");
                        list_for_each(subprogram->args, argument2) {
                             if (argument2->usage != LEX_SUBPROGRAM_ARGUMENT_USAGE_OUT)
                                  fprintf(fp, ", %s", argument2->name);
                        }

                        fprintf(fp, ", dims_%s)\n", argument->name);
                   }
              }
          }


          /**** Check dimensions****/

          if (sub_type == SUBPROGRAM_TYPE_GENERAL) {
              list_for_each(subprogram->args, argument) {
                   if (argument->type.rank > 0 &&
                       argument->usage == LEX_SUBPROGRAM_ARGUMENT_USAGE_IN) {
                        for (i = 0; i < argument->type.rank; ++i) {
                             ii = argument->type.rank - i - 1;
                             fprintf(fp, "%sdims = collect(UInt, size(%s))\n", bxis4(indent), argument->name);
                             fprintf(fp, "%sif dims[%d] != dims_%s[%d]\n", bxis4(indent), i + 1, argument->name, ii + 1);
                             indent++;
                             fprintf(fp, "%serror(@sprintf(\"dimension %d of %s input (%%d) must be == %%d\", dims[%d], dims_%s[%d]))\n",
                                     bxis4(indent), i + 1, argument->name, i + 1, argument->name, ii + 1);
                             indent--;
                             fprintf(fp, "%send\n", bxis4(indent));
                        }
                   }
              }
          }


          /**** Return variables ****/

          list_for_each(subprogram->args, argument) {
               if (argument->type.rank == 0 &&
                   argument->usage == LEX_SUBPROGRAM_ARGUMENT_USAGE_OUT)
                    fprintf(fp, "%s%s = Ref{%s}(0)\n", bxis4(indent), argument->name,
                            type_to_julia_c_type(&argument->type, 0, 0));
               else
               if (argument->type.rank > 0 &&
                   argument->usage == LEX_SUBPROGRAM_ARGUMENT_USAGE_OUT) {
                    fprintf(fp, "%s%s = Array{%s, %d}(undef, (", bxis4(indent), argument->name,
                            type_to_julia_type(&argument->type), argument->type.rank);
                    for (i = 0; i < argument->type.rank; ++i) {
                         fprintf(fp, "dims_%s[%d]", argument->name, argument->type.rank - i);
                         if (i + 1 < argument->type.rank)
                              fprintf(fp, ", ");
                    }
                    fprintf(fp, "))\n");
               }
          }


          /**** Create C memory maps of Julia arrays ****/

          list_for_each(subprogram->args, argument) {
               if (argument->type.rank > 1)
                   fprintf(fp, "%s%s_mmap = ccall((:array_from_mem, library_path), %s, (%s, Cint, Ref{Csize_t}, Csize_t, Cint), %s, %d, dims_%s, sizeof(%s), 1)\n",
                           bxis4(indent), argument->name, type_to_julia_c_type(&argument->type, 1, 0), type_to_julia_c_type(&argument->type, 1, 1), argument->name,
                           argument->type.rank, argument->name, type_to_julia_c_alias(&argument->type, 0, 0));
          }


          /**** Call to ccall ****/

          if (sub_type == SUBPROGRAM_TYPE_INIT ||
              sub_type == SUBPROGRAM_TYPE_FREE)
              postfix = "2";

          fprintf(fp, "%sr = ccall((:%s_%s%s, library_path), ",
                  bxis4(indent), d->prefix, subprogram->name, postfix);
          if (sub_type == SUBPROGRAM_TYPE_INIT)
               fprintf(fp, "Ptr{Cvoid}, ");
          else
               fprintf(fp, "%s, ",
                       type_to_julia_c_type(&subprogram->type, 0, 0));

          fprintf(fp, "(");

          if (sub_type != SUBPROGRAM_TYPE_INIT)
              fprintf(fp, "Ptr{Cvoid}, ");

          list_for_each(subprogram->args, argument) {
               fprintf(fp, "%s", type_to_julia_c_type(&argument->type,
                       argument->type.rank == 0 &&
                       argument->usage == LEX_SUBPROGRAM_ARGUMENT_USAGE_OUT,
                       argument->usage == LEX_SUBPROGRAM_ARGUMENT_USAGE_OUT));

               if (! list_is_last_elem(subprogram->args, argument))
                    fprintf(fp, ", ");
          }
          fprintf(fp, ")");

          if (sub_type != SUBPROGRAM_TYPE_INIT)
              fprintf(fp, ", d");

          list_for_each(subprogram->args, argument) {
               if (argument->type.rank <= 1)
                    fprintf(fp, ", %s",      argument->name);
               else
                    fprintf(fp, ", %s_mmap", argument->name);
          }

          fprintf(fp, ")\n");


          if (sub_type == SUBPROGRAM_TYPE_INIT)
               fprintf(fp, "%sif r == C_NULL\n",  bxis4(indent));
          else
               fprintf(fp, "%sif r == %s\n",           bxis4(indent),
                       bindx_c_error_conditional(d, subprogram->type.type));

          indent++;
          fprintf(fp, "%serror(\"%s_%s%s()\")\n", bxis4(indent),
                  d->prefix, subprogram->name, postfix);
          indent--;
          fprintf(fp, "%send\n", bxis4(indent));


          /**** Free C memory maps of Julia arrays ****/

          list_for_each(subprogram->args, argument) {
               if (argument->type.rank > 1)
                   fprintf(fp, "%sccall((:free_array, library_path), Cvoid, (%s, Cint), %s_mmap, %d)\n",
                           bxis4(indent), type_to_julia_c_type(&argument->type, 1, 0), argument->name,
                           argument->type.rank);
          }


          /**** Return value(s) ****/

          if (sub_type == SUBPROGRAM_TYPE_INIT)
               fprintf(fp, "%sr\n", bxis4(indent));
          else {
               if (subprogram->has_return_value) {
                    if (subprogram->options.flags & SUBPROGRAM_ARGUMENT_OPTION_MASK_ENUM_MASK)
                         fprintf(fp, "%smask_to_list(r, \"%s\", \"%s\")\n", bxis4(indent),
                                 subprogram->options.enum_index_to_mask,
                                 subprogram->options.enum_index_to_name);
                    else
                    if (subprogram->options.flags & SUBPROGRAM_ARGUMENT_OPTION_MASK_ENUM_ARRAY) {
                         fprintf(fp, "%sr = ccall((:xrtm_kernel_value_to_name, library_path), Cstring, (Cint, ), r)\n", bxis4(indent));
                         fprintf(fp, "%sif r == C_NULL\n", bxis4(indent));
                         indent++;
                         fprintf(fp, "%serror(\"%s()\")\n", bxis4(indent), subprogram->name);
                         indent--;
                         fprintf(fp, "%send\n", bxis4(indent));
                         fprintf(fp, "%sunsafe_string(r)\n", bxis4(indent));
                    }
                    else
                         fprintf(fp, "%sr\n", bxis4(indent));
               }
               else {
                    flag = 0;
                    if (subprogram_n_out_args(subprogram) != 0) {
                         fprintf(fp, "%s", bxis4(indent));
                         list_for_each(subprogram->args, argument) {
                              if (argument->usage == LEX_SUBPROGRAM_ARGUMENT_USAGE_OUT) {
                                   crap = "";
                                   if (argument->type.rank == 0)
                                        crap = "[]";
                                   if (! flag) {
                                        flag = 1;
                                        fprintf(fp, "%s%s", argument->name, crap);
                                   }
                                   else {
                                        fprintf(fp, ", %s%s", argument->name, crap);
                                   }
                              }
                         }
                         fprintf(fp, "\n");
                    }
               }
          }


          indent--;


          /**** End function declaration ****/
          fprintf(fp, "end\n");


          fprintf(fp, "\n");
          fprintf(fp, "\n");
     }

     return 0;
}



int bindx_write_jl(FILE **fp, const bindx_data *d, const char *name)
{
     bindx_write_c_header_top(fp[0]);
     fprintf(fp[0], "\n");

     bindx_write_c_util_header(fp[0], d);
     bindx_write_c_util_functions(fp[0], d, &d->subs_all);
     bindx_write_c_util_trailer(fp[0], d);

     write_header_top(fp[1]);
     fprintf(fp[1], "\n");

     fprintf(fp[1], "module %s\n", d->PREFIX);

     fprintf(fp[1], "using Printf\n");
     fprintf(fp[1], "\n");

     fprintf(fp[1], "library_path = \"../interfaces/%s\"\n", d->PREFIX);
     fprintf(fp[1], "\n");

     fprintf(fp[1], "struct %sError <: Exception end\n", d->PREFIX);
     fprintf(fp[1], "\n");

     write_global_consts(fp[1], d, &d->consts);
     fprintf(fp[1], "\n");
     fprintf(fp[1], "\n");

     write_utilities(fp[1], d);

     write_subprograms(fp[1], d, SUBPROGRAM_TYPE_INIT,    &d->subs_init);
     write_subprograms(fp[1], d, SUBPROGRAM_TYPE_FREE,    &d->subs_free);
     write_subprograms(fp[1], d, SUBPROGRAM_TYPE_GENERAL, &d->subs_general);

     fprintf(fp[1], "end\n");

     return 0;
}
